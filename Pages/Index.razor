@* ============================================================================
   Project:     SpaceInvaders
   File:        Index.razor
   Description: Main game page component with canvas rendering and input handling
   Author:      James Booth
   Created:     2024
   License:     MIT License - See LICENSE file in the project root
   Copyright:   (c) 2024-2026 James Booth
   Notice:      Space Invaders is (c) 1978 Taito Corporation.
                This emulator is for educational purposes only.
   ============================================================================ *@

@page "/"
@inject IJSRuntime JS
@inject HttpClient Http
@implements IAsyncDisposable
@using Microsoft.JSInterop

<div class="game-container" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onkeydown:preventDefault tabindex="0" @ref="_containerRef">
    @if (_isLoading)
    {
        <div class="loading">
            <!-- Space Invader Crab Icon -->
            <svg class="invader-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11 8" width="256" height="186" shape-rendering="crispEdges">
                <rect fill="currentColor" x="2" y="0" width="1" height="1.1"/>
                <rect fill="currentColor" x="8" y="0" width="1" height="1.1"/>
                <rect fill="currentColor" x="3" y="1" width="1" height="1.1"/>
                <rect fill="currentColor" x="7" y="1" width="1" height="1.1"/>
                <rect fill="currentColor" x="2" y="2" width="7" height="1.1"/>
                <rect fill="currentColor" x="1" y="3" width="2" height="1.1"/>
                <rect fill="currentColor" x="4" y="3" width="3" height="1.1"/>
                <rect fill="currentColor" x="8" y="3" width="2" height="1.1"/>
                <rect fill="currentColor" x="0" y="4" width="11" height="1.1"/>
                <rect fill="currentColor" x="0" y="5" width="1" height="1.1"/>
                <rect fill="currentColor" x="2" y="5" width="7" height="1.1"/>
                <rect fill="currentColor" x="10" y="5" width="1" height="1.1"/>
                <rect fill="currentColor" x="0" y="6" width="1" height="1.1"/>
                <rect fill="currentColor" x="2" y="6" width="1" height="1.1"/>
                <rect fill="currentColor" x="8" y="6" width="1" height="1.1"/>
                <rect fill="currentColor" x="10" y="6" width="1" height="1.1"/>
                <rect fill="currentColor" x="3" y="7" width="2" height="1.1"/>
                <rect fill="currentColor" x="6" y="7" width="2" height="1.1"/>
            </svg>
            <h1>SPACE INVADERS</h1>

            @if (_showPinGate)
            {
                <p class="pin-prompt">ENTER ACCESS PIN</p>
                <div class="pin-input-group" @onkeydown:stopPropagation>
                    <input type="password" class="pin-input"
                           @bind="_pinInput" @bind:event="oninput"
                           @onkeydown="OnPinKeyDown" @onkeydown:stopPropagation
                           placeholder="••••••••" maxlength="12"
                           disabled="@_pinRateLimited" />
                    <button class="acknowledge-btn pin-submit-btn" @onclick="SubmitPin" disabled="@_pinRateLimited">ENTER</button>
                </div>
                @if (!string.IsNullOrEmpty(_pinMessage))
                {
                    <p class="@PinMessageClass">@_pinMessage</p>
                }
            }
            else
            {
                <p>@_loadingMessage</p>

                @if (_missingRoms.Count > 0)
                {
                    <div class="missing-files missing-error">
                        <h2>ROM FILES MISSING</h2>
                        <p>The following ROM files are required to run the emulator:</p>
                        <ul>
                            @foreach (var rom in _missingRoms)
                            {
                                <li>@rom</li>
                            }
                        </ul>
                    </div>
                }
                else if (_missingSounds.Count > 0)
                {
                    <div class="missing-files missing-warning">
                        <h2>SOUND FILES MISSING</h2>
                        <p>The following sound files were not found. The game will run without sound:</p>
                        <ul>
                            @foreach (var sound in _missingSounds)
                            {
                                <li>@sound</li>
                            }
                        </ul>
                        <button class="acknowledge-btn" @onclick="AcknowledgeSoundWarning">CONTINUE WITHOUT SOUND</button>
                    </div>
                }
            }
        </div>
    }
    
    @if (!_isLoading)
    {
        <div class="copyright-label">Space Invaders is &copy; Taito Corporation.</div>
        <div class="copyright-label">This emulator is for educational purposes only.</div>
    }

    <div class="canvas-wrapper">
        <canvas id="gameCanvas" style="display: @(_isLoading ? "none" : "block")"></canvas>
        @if (_isPaused)
        {
            <div class="pause-overlay">PAUSED</div>
        }
    </div>
    
    @if (!_isLoading)
    {
        <div class="credit-hint">Press <span class="credit-key">C</span> to add credits and <span class="credit-key">1</span> or <span class="credit-key">2</span> players to start the game</div>
        <div class="controls-hint">Arrow keys <span class="credit-key"><span class="btn-text arrow-text">&larr;</span></span> <span class="credit-key"><span class="btn-text arrow-text">&rarr;</span></span> to move and <span class="credit-key">SPACE BAR</span> to fire &middot; <span class="credit-key">P</span> to pause</div>
    }
</div>

@code {
    private SpaceInvadersEmulator? _emulator;
    private PeriodicTimer? _gameLoop;
    private CancellationTokenSource? _cts;
    private bool _isLoading = true;
    private string _loadingMessage = "Loading...";
    private ElementReference _containerRef;
    private bool _hasInitialized;
    private DotNetObjectReference<Index>? _dotNetRef;
    private List<string> _missingRoms = new();
    private List<string> _missingSounds = new();
    private TaskCompletionSource? _soundWarningAcknowledged;
    private bool _isPaused;
    private int _highScore;

    // ── PIN gate ──────────────────────────────────────────────────────────────
    // Set PinEnabled = false to bypass the PIN check (useful for self-hosted / local dev).
    // When built in Debug configuration (dotnet watch run / dotnet run) the PIN gate is
    // automatically disabled. When published in Release configuration it is automatically
    // enabled. Override either constant manually if you need different behaviour.
#if DEBUG
    private readonly bool PinEnabled = false;
#else
    private readonly bool PinEnabled = true;
#endif
    // SHA-256 hash of the access PIN — the plain-text PIN is never stored here.
    // To change the PIN: compute sha256(<new-pin>) and update this constant.
    private const string PinHash = "32cfe433b39a94639da5512a41b122f45fe00c6a29b5e01852d491b6fb398b08";
    private bool _showPinGate;
    private string _pinInput = string.Empty;
    private string _pinMessage = string.Empty;
    private bool _pinError;
    private bool _pinRateLimited;
    private DateTime? _lastFailedAttempt;
    private System.Threading.Timer? _rateLimitTimer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (PinEnabled)
            {
                _showPinGate = true;
                StateHasChanged();
            }
            else
            {
                // Wait for the browser to commit two paint frames, ensuring the canvas
                // is fully in the DOM before initialization begins.
                await JS.InvokeVoidAsync("gameInterop.waitForPaint");
                await InitializeEmulatorAsync();
            }
        }
    }
    
    private async Task InitializeEmulatorAsync()
    {
        if (_hasInitialized) return;
        _hasInitialized = true;
        
        try
        {
            _emulator = new SpaceInvadersEmulator(JS, Http);
            
            _loadingMessage = "Loading game...";
            StateHasChanged();
            
            var success = await _emulator.InitializeAsync();
            
            _missingRoms = _emulator.MissingRoms;
            _missingSounds = _emulator.MissingSounds;
            
            if (!success)
            {
                // ROMs are missing — stay on loading screen with error
                _loadingMessage = "Unable to start the emulator.";
                StateHasChanged();
                return;
            }
            
            if (_missingSounds.Count > 0)
            {
                // Wait for player to acknowledge the sound warning
                _loadingMessage = "";
                _soundWarningAcknowledged = new TaskCompletionSource();
                StateHasChanged();
                await _soundWarningAcknowledged.Task;
            }
            else
            {
                // Extra delay to show loading screen
                await Task.Delay(1000);
            }
            
            _isLoading = false;
            StateHasChanged();
            
            // Focus the container for keyboard input
            await Task.Delay(100);
            await _containerRef.FocusAsync();
            
            // Initialize touch controls
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("gameInterop.initializeTouchControls", _dotNetRef);

            // Start the rAF render loop (JS-side, VSync-locked)
            await JS.InvokeVoidAsync("gameInterop.startRenderLoop");

            // Load persisted high score from localStorage — will be seeded into RAM
            // once the ROM signals it has finished its own RAM initialization.
            _highScore = await JS.InvokeAsync<int>("gameInterop.getHighScore");

            // Start the game logic loop at 60 Hz (C# PeriodicTimer)
            _cts = new CancellationTokenSource();
            _gameLoop = new PeriodicTimer(TimeSpan.FromMilliseconds(1000.0 / 60.0));
            _ = Task.Run(GameLoopAsync);
        }
        catch (Exception ex)
        {
            _loadingMessage = $"Error: {ex.Message}";
            StateHasChanged();
        }
    }
    
    private async Task GameLoopAsync()
    {
        try
        {
            while (await _gameLoop!.WaitForNextTickAsync(_cts!.Token))
            {
                if (!_isPaused)
                {
                    await _emulator!.RunFrameAsync();

                    // Keep writing the high score to ROM RAM until a readback confirms
                    // it has taken — the ROM may zero that region during its own init.
                    // Once confirmed, TrySeedHighScore becomes a no-op.
                    _emulator.TrySeedHighScore(_highScore);

                    // Save the high score to localStorage only once, on game-over.
                    // The ROM sets 0x20EF (gameMode) to 0 when the game ends; IsGameOver()
                    // detects the 1->0 transition so this fires exactly once per game.
                    if (_emulator.IsGameOver())
                    {
                        int score = _emulator.GetHighScore();
                        if (score > _highScore)
                        {
                            _highScore = score;
                            await JS.InvokeVoidAsync("gameInterop.setHighScore", _highScore);
                        }
                    }
                }
            }
        }
        catch (OperationCanceledException) { /* expected on dispose */ }
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is "p" or "P")
        {
            _isPaused = !_isPaused;
            _ = JS.InvokeVoidAsync(_isPaused ? "gameInterop.suspendAudio" : "gameInterop.resumeAudio");
            StateHasChanged();
            return;
        }
        _emulator?.KeyDown(e.Key);
    }
    
    private void OnKeyUp(KeyboardEventArgs e)
    {
        _emulator?.KeyUp(e.Key);
    }
    
    private void AcknowledgeSoundWarning()
    {
        _soundWarningAcknowledged?.TrySetResult();
    }
    
    [JSInvokable]
    public void OnTouchKeyDown(string key)
    {
        _emulator?.KeyDown(key);
    }
    
    [JSInvokable]
    public void OnTouchKeyUp(string key)
    {
        _emulator?.KeyUp(key);
    }
    
    private string PinMessageClass => _pinError ? "pin-message pin-error" : "pin-message";

    /// <summary>
    /// Sanitizes raw PIN input before hashing:
    /// 1. Caps length to prevent excessive resource use on adversarial input.
    /// 2. Strips control characters (null bytes, tabs, newlines, DEL, etc.).
    /// 3. Trims incidental leading/trailing whitespace.
    /// </summary>
    private static string SanitizePinInput(string raw)
    {
        if (string.IsNullOrEmpty(raw)) return string.Empty;

        const int MaxPinLength = 12;
        var span = raw.AsSpan(0, Math.Min(raw.Length, MaxPinLength));

        var sb = new System.Text.StringBuilder(span.Length);
        foreach (var c in span)
        {
            if (!char.IsControl(c)) sb.Append(c);
        }
        return sb.ToString().Trim();
    }

    private async Task SubmitPin()
    {
        if (_pinRateLimited) return;

        var sanitized = SanitizePinInput(_pinInput);
        _pinInput = string.Empty;

        if (sanitized.Length == 0)
        {
            _pinError = true;
            _pinMessage = "Please enter a PIN.";
            StateHasChanged();
            return;
        }

        var inputBytes = System.Text.Encoding.UTF8.GetBytes(sanitized);
        var hashBytes = System.Security.Cryptography.SHA256.HashData(inputBytes);
        var inputHash = Convert.ToHexString(hashBytes).ToLowerInvariant();

        if (inputHash == PinHash)
        {
            _showPinGate = false;
            StateHasChanged();
            await JS.InvokeVoidAsync("gameInterop.waitForPaint");
            await InitializeEmulatorAsync();
        }
        else
        {
            _lastFailedAttempt = DateTime.UtcNow;
            _pinRateLimited = true;
            _pinError = true;
            UpdateRateLimitMessage();
        }
    }

    private void UpdateRateLimitMessage()
    {
        var elapsed = (DateTime.UtcNow - _lastFailedAttempt!.Value).TotalSeconds;
        var remaining = (int)Math.Ceiling(10.0 - elapsed);
        _rateLimitTimer?.Dispose();

        if (remaining <= 0)
        {
            _pinRateLimited = false;
            _pinMessage = "Incorrect PIN.";
        }
        else
        {
            _pinMessage = $"Incorrect PIN. Please wait {remaining} second{(remaining == 1 ? "" : "s")}";
            _rateLimitTimer = new System.Threading.Timer(
                _ => InvokeAsync(UpdateRateLimitMessage),
                null,
                TimeSpan.FromSeconds(1),
                Timeout.InfiniteTimeSpan);
        }

        StateHasChanged();
    }

    private async Task OnPinKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SubmitPin();
    }

    public async ValueTask DisposeAsync()
    {
        _rateLimitTimer?.Dispose();
        _cts?.Cancel();
        _gameLoop?.Dispose();
        _cts?.Dispose();
        await JS.InvokeVoidAsync("gameInterop.stopRenderLoop");
        _dotNetRef?.Dispose();
    }
}
